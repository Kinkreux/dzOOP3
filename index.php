<html>
    <header>
        <title>Мое домашнее задание по лекции 3.3 "Пространства имен, перегрузка и встроенные интерфейсы и классы"</title>
        <style>
            h1, h2 {
                font-size: 18px;
            }

            body {
                max-width: 550px;
                margin-left: 25%;
            }
        </style>
    </header>
    <body>
        <h1>Мое домашнее задание по лекции 3.3 "Пространства имен, перегрузка и встроенные интерфейсы и классы"</h1>
            <h2>1. Мое понимание пространства имен</h2>
                <p>Пространство имен отражает структуру проекта:</p>
                <ul>
                    <li>Структуру файлов проекта;</li>
                    <li>Структуру ООП-проекта, фактически результат его проектирования;</li>
                    <li>Смысловую структуру, чтобы мы понимали, с чем мы сейчас работаем и что вызываем;</li>
                    <li>Структуру библиотек и других сторонних реализаций, где и как мы их используем.</li>
                </ul>
                <p>Структура - это про стандарты, читаемость и поддержку кода, про грамотную организацию кода. Это должен быть живой, рабочий документ, а не птица додо. Пространство имен как инструмент языка позволяет вызывать одинаково именованные классы в одном коде, иначе этого делать было бы нельзя.</p>
                <p>Пространство имен - это фактически виртуальная файловая система. Оно не только отражает (по стандартам) файловую структуру проекта, но и фактически использует особенности файловой системы как таковой:</p>
                <ul>
                    <li>Является по сути папкой, хранящей внутри себя классы и другие папки;</li>
                    <li>Позволяет задавать некий "корень", внутри которого мы можем дальше, при желании, указывать относительный путь до нашего класса в файловой системе (по стандартам наша фактическая и виртуальная папка совпадут, кроме слэшей);</li>
                    <li>Как и в файловой системе, если мы зашли в папку, то пока мы оттуда не вышли, все файлы в папке и внутри нее нам доступны. В файловой системе, конечно, это организовано гибче, но там другие пользовательские цели. Хотя механизм "домашней папки" в тех же Линуксах и менанизм определения пространства имен в процедурном файле крайне похожи.</li>
                </ul>
                <p>Соблюдение стандартов по именованию физических папок и пространств имен позволяет среди прочего написать один универсальный автозагрузчик, что правильно и профессионально. Кода в таком загрузчике мало, его работа до предела прозрачна: берем пространство имен, к которому обращаемся, заменяем слэши пространства имен на DIRECTORY_SEPARATOR, добавляем в начале путь до физического корня сервера, полчаем абсолютный путь для загрузки файла класса, который работает независимо ни от чего, кроме соблюдения стандартов.</p>
                <p>Пространство имен вкупе с автозагрузчиком также избавляет нас от гроздьев require и include.</p>
                <ul>
                    <li>Это дает возможность не морочиться над тем, что обязательно, а что может быть необязательно. С помощью пространства имен и автозагрузчика мы получаем всегда непосредственно тут класс, который нам тут нужен. Понятно, что он тут необходим, но мы так и так его получим (если он существует, а если нет - то упс и fatal error).</li>
                    <li>Это дает возможность внутри автозагрузчика не морочиться над тем, где что лежит, и не вносить правки, если вдруг мы создали еще одну папку или еще кучу папок. Создали, обратились, подключили универсальным загрузчиком и сразу все работает.</li>
                </ul>
                <p>Я вижу некоторую опасность в сликом узком определении пространства имен, потому что потом мы не сможем обратиться к классам, лежащим вне этого пространства. Но, возможно, у меня в голове не сложилось понимание того, как нужно распределять и хранить процедурные файлы, эксплуатирующие результаты проектирования и в т.ч. пространство имен.</p>
            <h2>2. Мое понимание исключений (Exception) и зачем они нужны</h2>
                <p>Исключения - это инструмент, который позволяет инкорпорировать ошибки внутрь кода и работать с ними, как с кодом:</p>
                <ol>
                    <li>Вызывать определенные функции в зависимости от наличия ошибок и их конкретных   параметров;</li>
                    <li>Направлять выполнение программы по определенному сценарию "потоку";</li>
                    <li>Ловить и обрабатывать ошибки, включая фатальные, не пугая пользователя, а используя некий "план B";</li>
                </ol>
                <p>Исключение - обычный класс, который можно расширять. Это позволяет выстраивать цепочки наследования обработки ошибок, то есть, по сути, - полноценную систему обработки ошибок внутри нашего кода согласно его логике.</p>
                <p>Это очень круто. Исключения надо использовать, это признак профессионализма и серьезного отношения к делу. Но времени должно жрать немеряно. Те самые 20% работы, которые занимают 80% времени, зуб даю.</p>
            <h2>3. Код Товара, Корзины и Заказа</h2>
                <p>Открыть в новом окне:</p>
                <ol>
                    <li><a href="example.php" target="_blank">Код Товара, Корзины и Заказа</a></li>
                    <li><a href="https://github.com/Kinkreux/dzOOP3" target="_blank">Репозиторий на Github</a></li>
                </ol>
    </body>
</html>
